/*******************************************************************************
 * Copyright (c) 2011, Jean-David Gadina <macmade@eosgarden.com>
 * Distributed under the Boost Software License, Version 1.0.
 * 
 * Boost Software License - Version 1.0 - August 17th, 2003
 * 
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 * 
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 ******************************************************************************/

/* $Id$ */

#import "HostFile.h"
#import "HostFileEntry.h"

static HostFile * __sharedInstance = nil;

@implementation HostFile

+ ( id )sharedInstance
{
    @synchronized( self )
    {
        if( __sharedInstance == nil )
        {
            __sharedInstance = [ [ super allocWithZone: NULL ] init ];
        }
    }
    
    return __sharedInstance;
}

+ ( id )allocWithZone:( NSZone * )zone
{
    ( void )zone;
    
    @synchronized( self )
    {
        return [ [ self sharedInstance ] retain ];
    }
}

- ( id )copyWithZone:( NSZone * )zone
{
    ( void )zone;
    
    return self;
}

- ( id )retain
{
    return self;
}

- ( NSUInteger )retainCount
{
    return UINT_MAX;
}

- ( oneway void )release
{}

- ( id )autorelease
{
    return self;
}

- ( id )init
{
    if( ( self = [ super init ] ) )
    {
        [ self refresh ];
    }
    
    return self;
}

- ( void )dealloc
{
    [ _entries release ];
    
    [ super dealloc ];
}

- ( void )refresh
{
    NSString       * file;
    NSError        * error;
    NSArray        * lines;
    NSString       * line;
    NSPredicate    * p1;
    NSArray        * parts;
    HostFileEntry * entry;
    NSString       * host;
    NSString       * part;
    
    error    = nil;
    _entries = [ [ NSMutableArray arrayWithCapacity: 50 ] retain ];
    file     = [ NSString stringWithContentsOfFile: @"/etc/hosts" encoding: NSUTF8StringEncoding error: &error ];
    
    if( error == nil )
    {
        lines = [ file componentsSeparatedByString: @"\n" ];
        p1    = [ NSPredicate predicateWithFormat: @"SELF MATCHES %@", @"(^\\s*[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+.+)" ];
        
        for( line in lines )
        {
            line = [ line stringByTrimmingCharactersInSet: [ NSCharacterSet whitespaceCharacterSet ] ];
            
            if( [ p1 evaluateWithObject: line ] )
            {
                parts = [ [ line stringByReplacingOccurrencesOfString: @"\t" withString: @" " ] componentsSeparatedByString: @" " ];
                
                for( part in parts )
                {
                    if( part == [ parts objectAtIndex: 0 ] )
                    {
                        continue;
                    }
                    
                    if( [ part length ] > 0 )
                    {
                        host = part;
                        break;
                    }
                }
                
                entry = [ HostFileEntry entryWithAddress: [ parts objectAtIndex: 0 ] host: host ];
                
                [ _entries addObject: entry ];
            }
        }
    }
}

- ( HostFileEntry * )entryWithHostname: ( NSString * )host
{
    HostFileEntry * entry;
    HostFileEntry * result;
    
    result = nil;
    
    for( entry in _entries )
    {
        if( [ entry.host isEqualToString: host ] )
        {
            result = entry;
        }
    }
    
    return result;
}

- ( NSArray * )entries
{
    return [ NSArray arrayWithArray: _entries ];
}

- ( void )writeNewEntry: ( HostFileEntry * )entry
{
    NSString * file;
    NSError  * error;
    
    [ self refresh ];
    
    if( [ self entryWithHostname: entry.host ] != nil )
    {
        return;
    }
    
    error = nil;
    file  = [ NSString stringWithContentsOfFile: @"/etc/hosts" encoding: NSUTF8StringEncoding error: &error ];
    
    if( error != nil )
    {
        return;
    }
    
    file = [ file stringByAppendingFormat: @"\n%@\t%@ # Managed by WebStart", entry.address, entry.host ];
    
    [ file writeToFile: @"/etc/hosts" atomically: YES encoding: NSUTF8StringEncoding error: &error ];
    
    if( error == nil )
    {
        [ self refresh ];
    }
}

- ( void )removeEntry: ( HostFileEntry * )entry
{
    NSString       * file;
    NSError        * error;
    NSArray        * lines;
    NSString       * line;
    NSString       * trimedLine;
    NSPredicate    * p1;
    NSArray        * parts;
    NSString       * host;
    NSString       * part;
    NSMutableArray * writeLines;
    
    [ self refresh ];
    
    if( [ self entryWithHostname: entry.host ] == nil )
    {
        return;
    }
    
    error      = nil;
    writeLines = [ NSMutableArray arrayWithCapacity: 50 ];
    file       = [ NSString stringWithContentsOfFile: @"/etc/hosts" encoding: NSUTF8StringEncoding error: &error ];
    
    if( error == nil )
    {
        lines = [ file componentsSeparatedByString: @"\n" ];
        p1    = [ NSPredicate predicateWithFormat: @"SELF MATCHES %@", @"(^\\s*[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+.+)" ];
        
        for( line in lines )
        {
            trimedLine = [ line stringByTrimmingCharactersInSet: [ NSCharacterSet whitespaceCharacterSet ] ];
            
            if( [ p1 evaluateWithObject: trimedLine ] )
            {
                parts = [ [ trimedLine stringByReplacingOccurrencesOfString: @"\t" withString: @" " ] componentsSeparatedByString: @" " ];
                
                for( part in parts )
                {
                    if( part == [ parts objectAtIndex: 0 ] )
                    {
                        continue;
                    }
                    
                    if( [ part length ] > 0 )
                    {
                        host = part;
                        break;
                    }
                }
                
                if( [ host isEqualToString: entry.host ] )
                {
                    continue;
                }
                else
                {
                    [ writeLines addObject: line ];
                }
            }
            else
            {
                [ writeLines addObject: line ];
            }
        }
        
        [ [ writeLines componentsJoinedByString: @"\n" ] writeToFile: @"/etc/hosts" atomically: YES encoding: NSUTF8StringEncoding error: &error ];
        
        if( error == nil )
        {
            [ self refresh ];
        }
    }
}

@end
